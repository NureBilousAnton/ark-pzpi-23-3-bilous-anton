                    МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
   ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



                           Кафедра Програмної інженерії




                                        Звіт
                              з практичної роботи №2
                     з дисципліни: «Аналіз та рефакторинг коду»
з теми: «Методи рефакторингу Фаулера для Rust: Rename, Extract та Remove
                                 Duplicated Code»




Виконав:                                                               Перевірив:
ст. гр. ПЗПІ-23-3                                                 ст. викл. каф. ПІ
Білоус А. А.                                                        Сокорчук І. П.




                                   Харків – 2025
                                                                               2
 2 МЕТОДИ РЕФАКТОРИНГУ ФАУЛЕРА ДЛЯ RUST: RENAME, EXTRACT
                      ТА REMOVE DUPLICATED CODE
     2.1 Вступ

     Рефакторинг є невід’ємною частиною процесу розробки програмного
забезпечення, що полягає у систематичній зміні внутрішньої структури коду без
зміни його зовнішньої поведінки. За визначенням Мартіна Фаулера, рефакторинг –
це дисциплінований спосіб реорганізації коду через серію невеликих змін, кожна з
яких залишає програму у працездатному стані.

     2.1.1 Мета роботи

     Метою даної роботи є вивчення та практична демонстрація застосування
трьох фундаментальних методів рефакторингу, описаних у книзі Мартіна
Фаулера «Refactoring: Improving the Design of Existing Code», у контексті мови
програмування Rust:
     а)   Rename (Перейменування) – покращення виразності назв елементів коду
     б)   Extract Method (Виділення методу) – декомпозиція складних функцій
     в)   Remove Duplicated Code (Усунення дублювання) – застосування
          принципу DRY

     2.1.2 Актуальність теми

     У сучасній розробці програмного забезпечення якість коду є критичним
фактором успіху проєкту. Технічний борг, що накопичується внаслідок швидких
рішень та еволюції вимог, може значно уповільнити розробку та збільшити кількість
помилок. Систематичний рефакторинг дозволяє:
      –   покращити читабельність та розуміння коду;
      –   спростити підтримку та розширення системи;
      –   знизити ризик виникнення помилок;
      –   підготувати кодову базу до впровадження нових функцій;
      –   зменшити технічний борг.
                                                                                  3
     Мова програмування Rust, завдяки своїй строгій системі типів та механізму
перевірки власності (ownership), надає унікальні переваги при рефакторингу,
забезпечуючи високий рівень безпеки змін на етапі компіляції.

     2.2 Теоретичні основи рефакторингу

     2.2.1 Визначення та принципи

     Рефакторинг – це процес зміни програмної системи таким чином, що
зовнішня поведінка коду залишається незмінною, але покращується його внутрішня
структура. Ключові принципи рефакторингу включають:
      –   збереження     функціональності   –   рефакторинг     не    додає   нових
          можливостей;
      –   поступові зміни – серія невеликих, керованих трансформацій;
      –   постійна верифікація – тестування після кожної зміни;
      –   систематичний підхід – використання каталогу перевірених методів.

     2.2.2 Важливість рефакторингу

     За даними дослідження, близько 80% часу розробки витрачається на читання
та розуміння існуючого коду. Якісний, добре структурований код значно знижує цей
показник. Рефакторинг дозволяє:
     а)   покращити      дизайн   програмного    забезпечення     –    виправлення
          архітектурних недоліків;
     б)   зробити код зрозумілішим – спрощення для майбутніх розробників;
     в)   допомогти знайти помилки – процес рефакторингу часто виявляє
          приховані дефекти;
     г)   прискорити розробку – чистий код легше модифікувати.

     2.2.3 Особливості рефакторингу в Rust

     Мова Rust надає унікальні переваги для безпечного рефакторингу:
      –   строга система типів – компілятор виявляє невідповідності типів;
      –   ownership model – автоматична перевірка коректності роботи з пам’яттю;
      –   trait system – потужний механізм абстракції та узагальнення;
                                                                               4
     –   компіляційні гарантії – якщо код компілюється, він працює коректно.

     2.3 Метод 1: Rename (перейменування)

     2.3.1 Опис проблеми

     Незрозумілі, оманливі або застарілі назви змінних, функцій, типів та модулів
створюють значне когнітивне навантаження при читанні коду. Типові проблеми
включають:
     –   однобуквені назви поза контекстом циклів;
     –   неочевидні абревіатури та скорочення;
     –   загальні назви типу “temp”, “data”, “info”;
     –   назви, що не відповідають поточному призначенню елемента;
     –   використання жаргону або специфічних термінів.

     2.3.2 Доцільність застосування методу

     Метод Rename є оптимальним для вирішення цієї проблеми, оскільки:
     –   не змінює логіку програми;
     –   має мінімальний ризик внесення помилок;
     –   значно покращує самодокументованість коду;
     –   зменшує потребу в коментарях;
     –   полегшує розуміння коду новими членами команди.

     2.3.3 Приклад застосування

     Код до рефакторингу:

     pub struct User {
         pub n: String,
         pub e: String,
         pub a: u8,
     }

     impl User {
         pub fn chk(&self) -> bool {
             self.a >= 18 && self.e.contains('@')
         }

         pub fn get_info(&self) -> String {
             format!("{} ({})", self.n, self.a)
                                                                                5
            }
     }


     Проблеми коду:
     а)   поля структури скорочені до однієї літери (“n”, “e”, “a”);
     б)   метод “chk” має незрозумілу назву;
     в)   метод “get_info” занадто загальний;
     г)   код потребує додаткових коментарів для пояснення.
     Код після рефакторингу:

     pub struct User {
         pub name: String,
         pub email: String,
         pub age: u8,
     }

     impl User {
         pub fn is_adult_with_valid_email(&self) -> bool {
             self.age >= 18 && self.email.contains('@')
         }

            pub fn format_name_and_age(&self) -> String {
                format!("{} ({})", self.name, self.age)
            }
     }


     2.3.4 Переваги отриманого коду

     а)   самодокументованість – код пояснює сам себе без коментарів;
     б)   виразність – кожна назва точно відображає призначення;
     в)   відповідність конвенціям Rust – булеві методи починаються з “is_”;
     г)   легкість підтримки – зрозуміло навіть через місяці після написання;
     д)   зменшення ментального навантаження – не потрібно запам’ятовувати
          скорочення.

     2.4 Метод 2: Extract Method (виділення методу)

     2.4.1 Опис проблеми

     Довгі функції, що виконують декілька різних завдань, створюють наступні
проблеми:
     –    складність розуміння загального алгоритму;
                                                                       6
–    порушення принципу єдиної відповідальності (SRP);
–    складність тестування окремих логічних блоків;
–    низька можливість повторного використання коду;
–    великий обсяг контексту для утримання в пам’яті.

2.4.2 Доцільність застосування методу

Extract Method є оптимальним рішенням, оскільки дозволяє:
–    розділити складну логіку на зрозумілі компоненти;
–    дати кожному блоку коду виразну назву;
–    покращити можливість тестування;
–    підвищити рівень абстракції головної функції;
–    застосувати принцип єдиної відповідальності.

2.4.3 Приклад застосування

Код до рефакторингу:

pub fn process_order(order_id: u64, user_id: u64) -> Result<(),
String> {
    // Перевірка користувача
    let user = database::get_user(user_id).ok_or("User not found")?;
    if user.age < 18 {
        return Err("User must be adult".into());
    }

    // Перевірка замовлення
    let order = database::get_order(order_id).ok_or("Order not
found")?;
    if order.total < 0.0 {
        return Err("Invalid order total".into());
    }

     // Обробка платежу
     let payment = Payment::new(order.total);
     if !payment.validate_amount() {
         return Err("Payment validation failed".into());
     }
     payment.process()?;

     Ok(())
}


Проблеми коду:
а)   функція виконує три різні завдання;
                                                                           7
б)   коментарі вказують на необхідність декомпозиції;
в)   складно тестувати окремі аспекти логіки;
г)   порушено принцип єдиної відповідальності;
д)   високий рівень деталізації змішаний з високорівневою логікою.
Код після рефакторингу:
Головна функція:

pub fn process_order(order_id: u64, user_id: u64) -> Result<(),
String> {
    let user = validate_user(user_id)?;
    let order = validate_order(order_id)?;
    process_payment(&order)?;
    Ok(())
}


Допоміжні функції:

fn validate_user(user_id: u64) -> Result<User, String> {
    let user = database::get_user(user_id)
        .ok_or("User not found")?;
    if user.age < 18 {
        return Err("User must be adult".into());
    }
    Ok(user)
}

fn validate_order(order_id: u64) -> Result<Order, String> {
    let order = database::get_order(order_id)
        .ok_or("Order not found")?;
    if order.total < 0.0 {
        return Err("Invalid order total".into());
    }
    Ok(order)
}

fn process_payment(order: &Order) -> Result<(), String> {
    let payment = Payment::new(order.total);
    if !payment.validate_amount() {
        return Err("Payment validation failed".into());
    }
    payment.process()
}


2.4.4 Переваги отриманого коду

а)   читабельність на високому рівні – головна функція показує алгоритм;
б)   модульність – кожна функція має чітко визначену відповідальність;
в)   тестованість – можливість незалежного тестування кожної функції;
                                                                             8
     г)   повторне використання – допоміжні функції можна використати окремо;
     д)   чіткі контракти – сигнатури типів показують входи та виходи;
     е)   простота змін – зміна однієї логіки не впливає на інші.

     2.5 Метод 3: Remove Duplicated Code (усунення дублювання)

     2.5.1 Опис проблеми

     Дублювання коду є однією з найпоширеніших проблем у програмуванні. Воно
призводить до:
      –   збільшення обсягу коду для підтримки;
      –   необхідності синхронних змін у багатьох місцях;
      –   високого ризику пропустити одне з місць при виправленні помилки;
      –   складності впровадження нових вимог;
      –   зростання ймовірності розбіжностей між копіями.

     2.5.2 Доцільність застосування методу

     Усунення дублювання згідно з принципом DRY (Don’t Repeat Yourself) є
оптимальним, оскільки:
      –   централізує логіку в одному місці;
      –   спрощує подальші зміни;
      –   зменшує кількість коду;
      –   підвищує консистентність поведінки;
      –   знижує ймовірність помилок.

     2.5.3 Приклад застосування

     Код до рефакторингу:

     pub fn save_user_to_file(user: &User) -> Result<(), std::io::Error> {
         let json = serde_json::to_string(user)?;
         let mut file = File::create("users.json")?;
         file.write_all(json.as_bytes())?;
         println!("User saved successfully");
         Ok(())
     }

     pub fn save_order_to_file(order: &Order) -> Result<(),
                                                                   9
std::io::Error> {
    let json = serde_json::to_string(order)?;
    let mut file = File::create("orders.json")?;
    file.write_all(json.as_bytes())?;
    println!("Order saved successfully");
    Ok(())
}

pub fn save_product_to_file(product: &Product) -> Result<(),
std::io::Error> {
    let json = serde_json::to_string(product)?;
    let mut file = File::create("products.json")?;
    file.write_all(json.as_bytes())?;
    println!("Product saved successfully");
    Ok(())
}


Проблеми коду:
а)   три майже ідентичні функції відрізняються лише типом даних;
б)   90% коду дубльовано;
в)   при зміні логіки потрібні синхронні зміни в трьох місцях;
г)   виправлення помилки вимагає змін у всіх функціях;
д)   додавання нового типу потребує створення ще однієї копії.
Код після рефакторингу:

use serde::Serialize;

pub fn save_to_file<T: Serialize>(
    data: &T,
    filename: &str,
    item_type: &str
) -> Result<(), std::io::Error> {
    let json = serde_json::to_string(data)?;
    let mut file = File::create(filename)?;
    file.write_all(json.as_bytes())?;
    println!("{} saved successfully", item_type);
    Ok(())
}

// Використання
save_to_file(&user, "users.json", "User")?;
save_to_file(&order, "orders.json", "Order")?;
save_to_file(&product, "products.json", "Product")?;


2.5.4 Переваги отриманого коду

а)   централізована логіка – одне місце для всіх змін;
б)   використання дженеріків – безпечна робота з різними типами;
                                                                         10
в)   зменшення обсягу коду – три функції замінені однією;
г)   простота розширення – додавання нових типів без нового коду;
д)   гарантії безпеки типів – компілятор перевіряє коректність;
е)   DRY принцип – повне дотримання «не повторюйся».

2.6 Процес та інструменти рефакторингу

2.6.1 Правильний підхід до рефакторингу

Успішний рефакторинг вимагає дотримання наступних принципів:
а)   наявність тестів:
            –   автоматичні тести повинні існувати до початку рефакторингу;
            –   тести є «страховою сіткою», що гарантує незмінність
                поведінки;
            –   якщо тестів немає – створіть їх перед рефакторингом.
б)   маленькі кроки:
            –   кожна зміна має бути мінімальною та атомарною;
            –   після кожної зміни код повинен компілюватись;
            –   уникайте одночасних змін у багатьох місцях.
в)   постійна верифікація:
            –   запускайте тести після кожної зміни;
            –   переконайтесь, що всі тести проходять успішно;
            –   у Rust додатково перевіряйте компіляцію.
г)   контроль версій:
            –   робіть коміт після кожного успішного кроку;
            –   можливість швидкого відкату при виникненні проблем;
            –   історія змін для аналізу процесу.

2.6.2 Інструменти екосистеми Rust

rust-analyzer
–    сучасний Language Server Protocol (LSP) сервер;
–    автоматичне перейменування символів по всій кодовій базі;
–    extract to function/variable;
                                                                     11
–   inline variable/function;
–   move module;
–   інтеграція з більшістю редакторів та IDE.
cargo clippy
–   статичний аналізатор коду з понад 750 перевірками;
–   виявлення неідіоматичного коду;
–   підказки щодо можливих покращень;
–   автоматичні виправлення через “--fix”.
cargo test
–   інтегрована система тестування;
–   автоматичний пошук та запуск тестів;
–   тестування прикладів у документації;
–   паралельне виконання для швидкості.
cargo fix
–   автоматичне виправлення деяких категорій проблем;
–   застосування пропозицій компілятора;
–   безпечні трансформації коду.

2.6.3 Коли застосовувати рефакторинг

Рекомендовані ситуації:
–   при додаванні нової функціональності до існуючого коду;
–   при виправленні помилок, коли виявляється структурна проблема;
–   під час code review як частина процесу перевірки;
–   коли код стає важким для розуміння;
–   при виявленні дублювання або «запахів коду».
Ситуації, коли рефакторинг не рекомендується:
–   код працює і не планується його зміна;
–   одночасно з додаванням нової функціональності;
–   перед критичним deadline проєкту;
–   без розуміння коду та без тестів;
–   заради рефакторингу без реальної потреби.
                                                                              12
     2.7 Висновки

     2.7.1 Основні результати роботи

     У ході виконання даної роботи було детально вивчено та продемонстровано
застосування трьох фундаментальних методів рефакторингу Мартіна Фаулера у
контексті мови програмування Rust:
     а)   Rename    (Перейменування)    –   покращення   виразності    назв   для
          самодокументованого коду;
     б)   Extract Method (Виділення методу) – декомпозиція складних функцій
          згідно з принципом єдиної відповідальності;
     в)   Remove Duplicated Code (Усунення дублювання) – застосування
          принципу DRY через узагальнення коду.
     Кожен метод був проілюстрований практичними прикладами коду до та після
рефакторингу з детальним аналізом проблем, рішень та переваг.

     2.7.2 Ключові висновки

     а)   систематичний підхід – рефакторинг повинен бути регулярною
          практикою, а не одноразовим процесом;
     б)   безпека змін – у Rust компілятор забезпечує високий рівень впевненості
          у коректності рефакторингу;
     в)   маленькі кроки – поступові зміни з постійною верифікацією мінімізують
          ризики;
     г)   інструментальна підтримка – екосистема Rust надає потужні інструменти
          для автоматизації рефакторингу.

     2.7.3 Практична цінність

     Застосування розглянутих методів рефакторингу дозволяє:
      –   значно покращити читабельність та підтримуваність коду;
      –   знизити технічний борг проєкту;
      –   спростити впровадження нових функцій;
      –   зменшити кількість помилок через краще структурований код;
                                                                                        13
      –    підвищити продуктивність команди розробки.

     2.7.4 Рекомендації

     На основі проведеного дослідження можна сформулювати наступні
рекомендації:
     а)    впроваджувати культуру регулярного рефакторингу в команді;
     б)    використовувати автоматизовані інструменти (rust-analyzer, clippy);
     в)    підтримувати високе покриття тестами для безпечного рефакторингу;
     г)    проводити code review з акцентом на якість структури коду;
     д)    дотримуватись принципу «залишати код чистішим, ніж він був».

     2.8 Список використаних джерел

      а)   Fowler, M. (2018). Refactoring: Improving the Design of Existing Code
           (2nd ed.). Addison-Wesley Professional.
      б)   Klabnik, S., & Nichols, C. (2023). The Rust Programming Language (2nd
           ed.). No Starch Press.
      в)   Rust API        Guidelines.   Retrieved   from   https://rust-lang.github.io/api-guidelines/
      г)   rust-analyzer User Manual. Retrieved from https://rust-analyzer.github.io/manual.html
      д)   Refactoring Catalog. Retrieved from https://refactoring.com/catalog/
      е)   Martin, R. C. (2008). Clean Code: A Handbook of Agile Software
           Craftsmanship. Prentice Hall.
     ж)    Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns:
           Elements of Reusable Object-Oriented Software. Addison-Wesley.
      и)   The Rust Reference. Retrieved from https://doc.rust-lang.org/reference/
      к)   Clippy Documentation. Retrieved from https://rust-lang.github.io/rust-clippy/
      л)   Beck, K. (2002). Test Driven Development: By Example. Addison-Wesley
           Professional.
                                                                              14
                                 ДОДАТОК А
                                     Відеозапис

Відеозапис презентації практичної роботи: https://youtu.be/G8Tixay1qcs

Хронологічний опис відеозапису:
00:00 Вступ
00:17 Що таке рефакторинг?
00:48 Метод 1: Rename (Перейменування)
01:16 Приклад: Rename (До)
01:43 Приклад: Rename (Після)
02:08 Метод 2: Extract Method (Виділення методу)
02:34 Приклад: Extract Method (До)
02:58 Приклад: Extract Method (Після), Основна функція
03:18 Приклад: Extract Method (Після), відокремлені функції
03:44 Метод 3: Remove Duplicated Code
04:14 Приклад: Remove Duplicated Code (До)
04:41 Приклад: Remove Duplicated Code (Після)
05:09 Процес рефакторингу
05:39 Коли НЕ треба рефакторити?
06:08 Інструменти для рефакторингу в Rust
06:42 Висновки
07:17 Джерела
07:42 Дякую за увагу!
                                                  15
                 ДОДАТОК Б
                 Презентація




Методи рефакторингу Фаулера для Rust:
Rename, Extract та Remove Duplicated Code




                                              1



          Що таке рефакторинг?

Систематична зміна структури коду без зміни
             його поведінки

                  Мета:
       • Покращення читабельності
       • Спрощення підтримки
       • Зменшення технічного боргу
    Компілятор Rust — ваш союзник при
             рефакторингу
                                              2
                                                    16




    Метод 1: Rename (Перейменування)
• Проблема: Незрозумілі або оманливі назви
• Вирішення: Зробіть назви виразними та
  відповідними змісту
               Коли застосовувати:
    • Назва не відображає призначення
    • Використано абревіатури або жаргон
    • Вимоги змінились, а назви — ні

                                                3


              Приклад: Rename (До)

 pub struct User {
     pub n: String,
     pub e: String,
     pub a: u8,
 }

 impl User {
     pub fn chk(&self) -> bool {
         self.a >= 18 && self.e.contains('@')
     }
     pub fn get_info(&self) -> String {
         format!("{} ({})", self.n, self.a)
     }
 }




Проблеми: Абревіатури n, e, a; незрозуміла
           назва методу chk                     4
                                                               17



              Приклад: Rename (Після)

   pub struct User {
       pub name: String,
       pub email: String,
       pub age: u8,
   }

   impl User {
       pub fn is_adult_with_valid_email(&self) -> bool {
           self.age >= 18 && self.email.contains('@')
       }
       pub fn format_name_and_age(&self) -> String {
           format!("{} ({})", self.name, self.age)
       }
   }



Код самодокументується, не потребує коментарів
                                                           5




  Метод 2: Extract Method (Виділення методу)
 • Проблема: Довгі функції, які роблять багато
   речей
 • Вирішення: Виділити фрагменти коду в
   окремі методи
                 Коли застосовувати:
    • Функція довша за один екран
    • Блок коду має чіткий смисл
    • Частина функції може мати окрему назву
                                                           6
                                                                                18




                      Приклад: Extract Method (До)

pub fn process_order(order_id: u64, user_id: u64) -> Result<(), String> {
    // Перевірка користувача
    let user = database::get_user(user_id).ok_or("User not found")?;
    if user.age < 18 {
        return Err("User must be adult".into());
    }
    // Перевірка замовлення
    let order = database::get_order(order_id).ok_or("Order not found")?;
    if order.total < 0.0 {
        return Err("Invalid order total".into());
    }
    // Обробка платежу
    let payment = Payment::new(order.total);
    if !payment.validate_amount() {
        return Err("Payment validation failed".into());
    }
    payment.process()?;

     Ok(())
}




                                                                            7




    Приклад: Extract Method (Після), Основна функція

pub fn process_order(order_id: u64, user_id: u64) -> Result<(), String> {
    let user = validate_user(user_id)?;
    let order = validate_order(order_id)?;
    process_payment(&order)?;
    Ok(())
}




                                                                            8
                                                                                 19




        Приклад: Extract Method (Після), відокремлені функції

 fn validate_user(user_id: u64) -> Result<User, String> {
     let user = database::get_user(user_id).ok_or("User not found")?;
     if user.age < 18 {
         return Err("User must be adult".into());
     }
     Ok(user)
 }
 fn validate_order(order_id: u64) -> Result<Order, String> {
     let order = database::get_order(order_id).ok_or("Order not found")?;
     if order.total < 0.0 {
         return Err("Invalid order total".into());
     }
     Ok(order)
 }
 fn process_payment(order: &Order) -> Result<(), String> {
     let payment = Payment::new(order.total);
     if !payment.validate_amount() {
         return Err("Payment validation failed".into());
     }
     payment.process()
 }




                                                                             9




               Метод 3: Remove Duplicated Code
• Проблема: Той самий код повторюється в різних
  місцях
• Вирішення: Винести дублювання в окрему
  функцію/метод
              Принцип DRY: Don't Repeat Yourself

                         Коли застосовувати:
   • Повторення коду з додаванням змін
   • Однакова логіка в різних місцях
   • Необхідна синхронізація змін в кількох місцях
                                                                            10
                                                                                     20




                   Приклад: Remove Duplicated Code (До)

pub fn save_user_to_ﬁle(user: &User) -> Result<(), std::io::Error> {
    let json = serde_json::to_string(user)?;
    let mut ﬁle = File::create("users.json")?;
    ﬁle.write_all(json.as_bytes())?;
    println!("User saved successfully");
    Ok(())
}
pub fn save_order_to_ﬁle(order: &Order) -> Result<(), std::io::Error> {
    let json = serde_json::to_string(order)?;
    let mut ﬁle = File::create("orders.json")?;
    ﬁle.write_all(json.as_bytes())?;
    println!("Order saved successfully");
    Ok(())
}
pub fn save_product_to_ﬁle(product: &Product) -> Result<(), std::io::Error> {
    let json = serde_json::to_string(product)?;
    let mut ﬁle = File::create("products.json")?;
    ﬁle.write_all(json.as_bytes())?;
    println!("Product saved successfully");
    Ok(())
}




                                                                                11




          Приклад: Remove Duplicated Code (Після)

use serde::Serialize;

pub fn save_to_ﬁle<T: Serialize>(
    data: &T,
    ﬁlename: &str,
    item_type: &str
) -> Result<(), std::io::Error> {
    let json = serde_json::to_string(data)?;
    let mut ﬁle = File::create(ﬁlename)?;
    ﬁle.write_all(json.as_bytes())?;
    println!("{} saved successfully", item_type);
    Ok(())
}
// Використання
save_to_ﬁle(&user, "users.json", "User")?;
save_to_ﬁle(&order, "orders.json", "Order")?;
save_to_ﬁle(&product, "products.json", "Product")?;




      Один метод, легше підтримувати, менше коду
                                                                                12
                                                      21



          Процес рефакторингу

           Правильний підхід:
1. Переконайтесь, що є тести (або напишіть їх)
2. Робіть маленькі кроки — по одній зміні
3. Запускайте тести після кожної зміни
4. Коміт після кожного успішного кроку
                  В Rust:
  • cargo test — ваша страховка
  • cargo clippy — підказує покращення
  • Компілятор зловить більшість помилок
                                                 13



       Коли НЕ треба рефакторити?

         Уникайте рефакторингу:
 • Код працює і ніхто до нього не доторкається
 • Під час додавання нових функцій
 • Перед deadline проєкту
 • Без тестів та розуміння коду
               Рефакторіть:
  • При додаванні функцій до існуючого коду
  • При виправленні багів
  • Під час code review
  • Коли код стає незрозумілим                   14
                                                 22



   Інструменти для рефакторингу в Rust
• rust-analyzer — сучасний LSP сервер котрий
  надає аналіз коду, підказки та можливості
  рефакторингу. На прикладі редактору Helix:
    ▪ Space+r — перейменувати символ
    ▪ Space+a — швидкі виправлення та можливі
      дії рефакторингу
• cargo clippy — знаходить місця для
  покращення
• cargo fix — автоматично виправляє деякі
  проблеми
                                            15



                 Висновки
• Rename: Робіть назви виразними
• Extract Method: Одна функція = одна
  відповідальність
• Remove Duplicated Code: DRY принцип
              Золоті правила:
• Рефакторинг не змінює поведінку
• Маленькі кроки супроводжуються тестами
• Використовуйте інструменти Rust
• Регулярні маленькі покращення краще
  великого переписування за раз
                                            16
                                                             23



                     Джерела

                       Книги:
• Martin Fowler "Refactoring: Improving the Design of
  Existing Code" (2nd Edition, 2018)
• Steve Klabnik, Carol Nichols "The Rust Programming
  Language"
                 Онлайн-ресурси:
 • Rust API Guidelines
 • rust-analyzer manual
 • refactoring.com — каталог методів рефакторингу
                                                        17




        ДЯКУЮ ЗА УВАГУ!



                                                        18

