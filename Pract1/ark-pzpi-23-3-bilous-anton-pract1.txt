                    МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
   ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



                           Кафедра Програмної інженерії




                                        Звіт
                              з практичної роботи №1
                     з дисципліни: «Аналіз та рефакторинг коду»
       з теми: «Правила оформлення програмного коду в екосистемі Rust»




Виконав:                                                               Перевірив:
ст. гр. ПЗПІ-23-3                                                 ст. викл. каф. ПІ
Білоус А. А.                                                        Сокорчук І. П.




                                   Харків – 2025
                                                                                2
  1 ПРАВИЛА ОФОРМЛЕННЯ ПРОГРАМНОГО КОДУ В ЕКОСИСТЕМІ
                                     RUST
     1.1 Вступ

     Підтримання якості та читабельності програмного коду є фундаментальним
завданням сучасної розробки програмного забезпечення. У контексті цієї роботи
розглядається мова програмування Rust – системна мова, яка поєднує високу
продуктивність з безпекою пам’яті та потокобезпечністю.
     Особливістю екосистеми Rust є те, що стандартизація коду не є
рекомендацією, а становить фундаментальну частину культури розробки. На
відміну від багатьох інших мов програмування, де існують різноманітні стилі
кодування (наприклад, у Python є PEP 8, але багато команд розробляють власні
варіації), Rust-спільнота виробила єдиний офіційний стиль кодування, який
забезпечується інструментом “rustfmt”. Це означає, що код Rust виглядає однаково
незалежно від автора – чи то команда з Google, Mozilla, чи невеликий стартап.
     Мета    роботи:   дослідити   та   систематизувати    правила   оформлення
програмного коду в мові Rust, проаналізувати інструменти забезпечення якості
коду та продемонструвати практичне застосування рекомендацій на конкретних
прикладах.

     1.2 Значення стандартизації коду
     1.2.1 Переваги єдиного стилю кодування

     Стандартизація коду в екосистемі Rust забезпечує низку суттєвих переваг:
      –   Уніфікований досвід розробки. Єдиний стиль означає, що розробник
          отримує однаковий досвід при роботі з різними проєктами. Не потрібно
          перенавчатися або адаптуватися до специфічних конвенцій кожної
          команди.
      –   Зменшення когнітивного навантаження. При читанні коду, написаного
          іншими розробниками, програміст автоматично знає, де шукати
          визначення функцій, як структуровані модулі, яка логіка розташування
          коду. Це значно прискорює розуміння чужого коду.
                                                                              3
     –   Спрощення     процесу    code   review.    Коли   форматування    коду
         стандартизоване та автоматизоване, команда може фокусуватися на
         архітектурних рішеннях, логіці програми та потенційних помилках,
         замість витрачати час на суперечки про відступи, розташування дужок або
         довжину рядків.
     –   Прискорення онбордингу. Нові члени команди можуть швидше почати
         продуктивно працювати, оскільки всі Rust-проєкти виглядають знайомо
         та передбачувано.

     1.2.2 Мінімізація помилок через консистентність

     Консистентність коду безпосередньо впливає на кількість помилок у
програмному забезпеченні. Коли код написаний в єдиному стилі, розробники
швидше помічають аномалії та відхилення від норми, які можуть вказувати на
потенційні баги. Крім того, автоматизовані інструменти аналізу коду працюють
ефективніше на стандартизованому коді.

     1.3 Структура проєкту в екосистемі Rust
     1.3.1 Організація проєкту за допомогою Cargo

     Rust має чітку та передбачувану структуру проєкту, визначену Cargo –
офіційним менеджером пакунків та системою збірки. Cargo аналогічний до npm у
Node.js, pip у Python або Maven у Java, але з більш суворими конвенціями щодо
структури.
     Стандартна структура Rust-проєкту виглядає наступним чином:

     my_project/
     ├── Cargo.toml            # Маніфест проєкту
     ├── Cargo.lock            # Залежності (автогенерований)
     ├── src/
     │   ├── main.rs           # Точка входу для бінарної програми
     │   ├── lib.rs            # Точка входу для бібліотеки
     │   ├── module.rs         # Оголошення модуля
     │   └── module/
     │        ├── mod.rs       # Альтернативне оголошення модуля
     │        └── submodule.rs
     ├── tests/                # Інтеграційні тести
     ├── benches/              # Бенчмарки продуктивності
     └── examples/             # Приклади використання
                                                                                   4
        Файл “Cargo.toml” містить метадані проєкту: назву, версію, автора, опис, а
також список залежностей з вказаними версіями. Це центральний конфігураційний
файл проєкту.
        Файл “Cargo.lock” автоматично генерується Cargo і фіксує точні версії всіх
залежностей, включаючи транзитивні. Це гарантує відтворюваність збірки на
різних машинах.
        Директорія “src/” містить весь вихідний код:
        –   “main.rs” використовується як точка входу для виконуваних програм
            (бінарних crate);
        –   “lib.rs” є точкою входу для бібліотек (library crate);
        –   Модулі організуються або як окремі файли, або як директорії з файлом
            “mod.rs” всередині.
        Директорія “tests/” містить інтеграційні тести, які тестують публічний API
бібліотеки як зовнішні користувачі.
        Директорія “benches/” призначена для бенчмарків – тестів продуктивності
коду.
        Директорія “examples/” містить приклади використання бібліотеки, які
компілюються як окремі виконувані файли.

        1.3.2 Принципи організації модулів

        Організація коду в модулі є ключовим аспектом архітектури Rust-програм.
Rust використовує систему модулів для логічного групування пов’язаного
функціоналу:

        // src/lib.rs
        pub mod network {
            pub mod client;
            pub mod server;
        }

        pub mod database {
            pub mod connection;
        }
                                                                                   5
      Приватність за замовчуванням: на відміну від багатьох інших мов, у Rust
все є приватним за замовчуванням. Це змушує розробників свідомо проєктувати
публічний API за допомогою ключового слова “pub”.
      Принцип єдиної відповідальності: кожен модуль має займатися однією
конкретною областю функціональності. Наприклад, модуль “network” відповідає за
мережеву взаємодію і містить підмодулі “client” та “server”, а модуль “database” – за
роботу з базою даних.
      Ієрархічна структура: модулі можуть містити підмодулі, створюючи
деревоподібну структуру, яка відображає логічну організацію функціональності.

      1.4 Правила форматування коду
      1.4.1 Відступи та вирівнювання

      Rust має чіткі правила щодо форматування коду, які усувають традиційні
«релігійні війни» між розробниками:
      Відступи: завжди 4 пробіли. На відміну від дебатів між табуляцією і пробілами
в інших мовах, у Rust на це є однозначна відповідь. Використання 4 пробілів
закріплено в офіційному стилі та автоматично забезпечується інструментом
“rustfmt”.
      Довжина рядка: максимум 100 символів. Ця довжина обрана як компроміс
між читабельністю на сучасних моніторах та можливістю комфортно працювати з
розділеним екраном (наприклад, код і тести поруч).
      Стиль розташування дужок. Rust використовує K&R-подібний стиль:

      fn example() {
          if condition {
              // код
          } else {
              // код
          }
      }


      Відкриваюча дужка знаходиться на тому ж рядку, що й оголошення,
закриваюча – на новому рядку з тим самим рівнем відступу, що й відповідна
конструкція.
                                                                                    6
        1.4.2 Вирівнювання багаторядкових конструкцій

        Для багаторядкових виразів “rustfmt” автоматично застосовує розумне
вирівнювання, яке підвищує читабельність та зменшує розмір змін при підтримці
коду:

        let result = some_long_function_name(
            first_parameter,
            second_parameter,
            third_parameter,
        );


        Параметри вирівнюються вертикально, кома після останнього параметра
допускається і навіть рекомендується для зручності додавання нових параметрів.

        1.5 Конвенції іменування
        1.5.1 Стилі іменування для різних елементів

        Rust має чіткі та логічні конвенції іменування для різних елементів мови:

Елемент коду        Стиль іменування                  Приклад
Змінні              “snake_case”                      “user_name”, “total_count”
Функції             “snake_case”                      “calculate_sum”, “process_data”
Методи              “snake_case”                      “get_value”, “set_property”
Типи даних          “PascalCase”                      “UserAccount”,
                                           “DatabaseConnection”
Структури           “PascalCase”           “Point”, “Rectangle”
Енуми               “PascalCase”           “Option”, “Result”
Трейти              “PascalCase”           “Display”, “Iterator”
Константи           “SCREAMING_SNAKE_CASE” “MAX_SIZE”,
                                       “DEFAULT_TIMEOUT”
Статичні змінні “SCREAMING_SNAKE_CASE” “GLOBAL_CONFIG”
Макроси         “snake_case!”          “println!”, “vec!”

        Особливість макросів. Макроси в Rust використовують “snake_case” з
обов’язковим знаком оклику (“!”) в кінці, що відразу відрізняє їх від звичайних
функцій. Це важливо, оскільки макроси працюють на етапі компіляції та мають
іншу семантику.
                                                                                 7
     1.5.2 Автоматична перевірка конвенцій

     Найкраща особливість Rust – компілятор попереджає про порушення
конвенцій іменування. Якщо розробник напише функцію з великої літери або
використає “camelCase” для змінної, компілятор видасть попередження:

     warning: function `Calculate` should have a snake case name
       --> src/main.rs:1:4
        |
     1 | fn Calculate(x: i32) -> i32 {
        |    ^^^^^^^^^ help: convert the identifier to snake case:
     `calculate`


     Це допомагає підтримувати консистентність навіть без додаткових
інструментів статичного аналізу.

     1.5.3 Приклад правильного іменування

     Розглянемо порівняння хорошого та поганого стилів:
     Хороший приклад:

     fn calculate_product(x: i32, y: i32) -> i32 {
         x * y
     }


     Поганий приклад:

     fn Calculate(X:i32,y:i32) -> i32
     {
     let z=X*y;
     return z;
     }


     У хорошому прикладі:
      –   назва функції у “snake_case”;
      –   правильні відступи навколо типів параметрів;
      –   тіло функції містить лише необхідний вираз;
      –   в Rust останній вираз без крапки з комою автоматично є значенням, що
          повертається.
                                                                                8
      У поганому прикладі порушено майже всі конвенції: назва функції,
відсутність пробілів, неправильне розташування дужок, зайва змінна та явний
“return” там, де він не потрібен.

      1.6 Коментарі та документація
      1.6.1 Принципи коментування коду

      Основний принцип коментування в Rust: пояснюйте «чому», а не «що».
      Приклад надлишкового коментаря:

      // Погано: коментар не додає корисної інформації
      let items = Vec::new(); // Створюємо вектор


      Приклад корисного коментаря:

      // Добре: пояснює архітектурне рішення
      // Використовуємо Vec замість масиву, бо
      // розмір не відомий на етапі компіляції
      let items = Vec::new();


      Перший приклад є класичним зразком надлишкового коментаря – код сам
собою очевидний. Такі коментарі лише захаращують код і можуть застаріти, якщо
код зміниться, а коментар залишиться незмінним.
      Натомість другий приклад пояснює неочевидне архітектурне рішення – чому
обрано динамічний вектор замість статичного масиву. Це цінна інформація для
майбутніх підтримувачів коду.

      1.6.2 Коли використовувати коментарі

      Коментарі доцільні в наступних ситуаціях:
      –   пояснення складної бізнес-логіки, яку неможливо зробити очевидною
          через код;
      –   документування      обхідних   шляхів   (workarounds)   та   причин   їх
          застосування;
      –   опис обмежень та крайніх випадків;
      –   пояснення неочевидних оптимізацій та причин їх використання;
      –   «TODO»-коментарі для позначення незавершеного функціоналу.
                                                                            9
     1.6.3 Документація як частина коду

     В Rust документація не є додатковим файлом десь збоку, а становить
інтегровану частину вихідного коду. Документаційні коментарі пишуться з трьома
слешами (“///”) і підтримують Markdown-форматування:

     /// Обчислює факторіал числа.
     ///
     /// # Приклади
     ///
     /// ```
     /// let result = factorial(5);
     /// assert_eq!(result, 120);
     /// ```
     ///
     /// # Panic
     ///
     /// Функція не викликає panic для будь-яких вхідних даних.
     pub fn factorial(n: u32) -> u32 {
         (1..=n).product()
     }


     1.6.4 Автоматичне тестування документації

     Унікальна особливість Rust – приклади коду всередині документації
автоматично тестуються при запуску “cargo test”. Це означає, що документація
завжди актуальна: якщо API змінюється, застарілі приклади в документації
перестануть компілюватися, і розробник отримає помилку.
     Документація автоматично генерується командою “cargo doc” у зручний
HTML-формат з навігацією, пошуком та перехресними посиланнями. Стандартна
структура документації включає:
      –   короткий опис функціональності;
      –   секцію з прикладами (“# Examples”);
      –   опис параметрів та значення, що повертається;
      –   секцію з можливими помилками (“# Errors”);
      –   секцію з умовами panic (“# Panics”);
      –   секцію з міркуваннями безпеки (“# Safety”) для unsafe-коду.
                                                                              10
     1.7 Інструменти забезпечення якості коду
     1.7.1 Rustfmt: автоматичне форматування

     “rustfmt” – це офіційний інструмент форматування коду, який входить
до стандартної поставки Rust через “rustup”. Він повністю автоматизує процес
форматування коду відповідно до офіційного стилю.
     Базове використання:

     # Форматування всього проєкту
     cargo fmt

     # Перевірка форматування без внесення змін
     cargo fmt -- --check


     Прапорець “--check” особливо корисний для CI/CD-систем: він перевіряє
форматування без внесення змін і повертає ненульовий код виходу, якщо код не
відформатований належним чином.
     Інтеграція в робочий процес:
     Більшість команд інтегрують “cargo fmt” в:
      –   Pre-commit хуки Git для автоматичного форматування перед комітом;
      –   Pre-push хуки для фінальної перевірки;
      –   CI/CD pipeline для валідації форматування на сервері;
      –   IDE (через rust-analyzer) для форматування на льоту.
     Це повністю усуває суперечки про стиль коду в code review – якщо “cargo fmt
-- --check” пройшов успішно, форматування гарантовано коректне.
     Налаштування:
     Хоча за замовчуванням “rustfmt” працює чудово для 99% проєктів, можна
налаштувати деякі опції через файл “rustfmt.toml” або “.rustfmt.toml” у корені
проєкту. Наприклад:

     max_width = 100
     tab_spaces = 4
     edition = "2021"
                                                                               11
     1.7.2 Clippy: розумний лінтер

     “Clippy” – це потужний лінтер для Rust, розроблений спільнотою і офіційно
підтримуваний командою Rust. Він містить понад 500 різноманітних перевірок коду.
     Категорії перевірок Clippy:
     а)   Correctness (коректність) – виявлення потенційних помилок та
          некоректної поведінки;
     б)   Style (стиль) – ідіоматичність коду та дотримання конвенцій;
     в)   Complexity (складність) – виявлення надмірно складних конструкцій;
     г)   Performance (продуктивність) – можливості оптимізації;
     д)   Pedantic (педантичність) – додаткові стилістичні перевірки;
     е)   Nursery (експериментальні) – нові перевірки в стадії тестування.
     Використання:

     # Базовий запуск лінтера
     cargo clippy

     # Строгий режим: всі попередження як помилки
     cargo clippy -- -D warnings

     # Автоматичне виправлення деяких проблем
     cargo clippy --fix


     Приклади перевірок:
     Clippy виявляє, наприклад:
      –   непотрібні “.clone()” або “.to_string()”;
      –   неефективні цикли, які можна замінити на ітератори;
      –   порушення конвенцій іменування;
      –   можливості спрощення складних виразів;
      –   потенційні помилки з переповненням;
      –   неідіоматичні конструкції.
     Кожне попередження супроводжується детальним поясненням проблеми та
часто пропонує автоматичне виправлення.
                                                                                  12
     1.7.3 Rust-analyzer: інтеграція з IDE

     “rust-analyzer” – це сучасна реалізація Language Server Protocol (LSP) для Rust.
Він надає IDE та текстовим редакторам багатий набір можливостей:
      –   автодоповнення з контекстною інформацією про типи;
      –   перехід до визначення функцій, типів, модулів;
      –   пошук використань змінних та функцій;
      –   рефакторинг: перейменування, витяг функції, inline-змінна;
      –   inline-підказки типів для виведених типів;
      –   діагностика помилок у реальному часі;
      –   швидкі виправлення (quick fixes) для типових проблем;
      –   підтримка макросів з розгортанням;
      –   документація при наведенні курсора.
     Rust-analyzer працює з:
      –   Visual Studio Code (офіційне розширення);
      –   IntelliJ IDEA / CLion;
      –   Vim / Neovim (через плагіни LSP);
      –   Emacs (через lsp-mode);
      –   Sublime Text;
      –   Будь-яким іншим редактором з підтримкою LSP.

     1.7.4 Додаткові інструменти екосистеми

     cargo-audit – інструмент для перевірки залежностей на наявність відомих
вразливостей безпеки. Він порівнює використовувані версії пакунків з базою даних
RustSec Advisory Database.

     cargo install cargo-audit
     cargo audit


     cargo-tarpaulin – інструмент аналізу покриття коду тестами для Linux. Генерує
звіти, які можна інтегрувати з сервісами типу Codecov або Coveralls.

     cargo install cargo-tarpaulin
     cargo tarpaulin --out Html
                                                                              13
      cargo-watch – інструмент для автоматичної перекомпіляції проєкту при зміні
файлів. Зручний під час розробки для швидкого зворотного зв’язку.

      cargo install cargo-watch
      cargo watch -x check -x test


      1.8 Тестування та Test-Driven Development
      1.8.1 Інтеграція тестування в Rust

      Тестування глибоко інтегроване в Rust на рівні мови, стандартної бібліотеки
та інструментів. Це робить написання тестів природною частиною процесу
розробки.
      Модульні тести:
      Модульні тести (unit tests) пишуться безпосередньо в тих самих файлах, що й
код, який вони тестують:

      pub fn add(a: i32, b: i32) -> i32 {
          a + b
      }

      #[cfg(test)]
      mod tests {
          use super::*;

             #[test]
             fn test_add_positive_numbers() {
                 assert_eq!(add(2, 3), 5);
             }

             #[test]
             fn test_add_negative_numbers() {
                 assert_eq!(add(-2, -3), -5);
             }

             #[test]
             #[should_panic]
             fn test_overflow() {
                 add(i32::MAX, 1);
             }
      }


      Атрибут “#[cfg(test)]” означає, що модуль компілюється лише під час
тестування, а не в релізній збірці. Кожна тестова функція позначається атрибутом
“#[test]”.
      Інтеграційні тести:
                                                                          14
     Інтеграційні тести розміщуються в окремій директорії “tests/” і тестують
публічний API бібліотеки як зовнішні користувачі:

     // tests/integration_test.rs
     use my_crate::public_function;

     #[test]
     fn test_public_api() {
         assert_eq!(public_function(), expected_value);
     }


     1.8.2 Макроси для тестування

     Rust надає багатий набір макросів для асерцій:
      –   “assert!(condition)” – перевіряє, що умова істинна;
      –   “assert_eq!(left, right)” – перевіряє рівність;
      –   “assert_ne!(left, right)” – перевіряє нерівність;
      –   “panic!("message")” – викликає паніку з повідомленням.
     При невдалих асерціях виводяться детальні повідомлення з рядком коду,
файлом та значеннями, що порівнюються.

     1.8.3 Запуск тестів

     # Запуск всіх тестів
     cargo test

     # Запуск конкретного тесту
     cargo test test_add_positive_numbers

     # Запуск тестів з виводом println!
     cargo test -- --nocapture

     # Паралельність тестів
     cargo test -- --test-threads=1


     За замовчуванням тести виконуються паралельно для швидкості. Cargo
автоматично знаходить і запускає всі тести в проєкті, включаючи приклади в
документації.

     1.8.4 Test-Driven Development в Rust

     Тісна інтеграція тестування робить TDD природним підходом у Rust:
     а)   написати тест, який не проходить;
                                                                              15
     б)    написати мінімальний код, щоб тест пройшов;
     в)    рефакторити код, підтримуючи зелені тести;
     г)    повторити цикл.
     Швидкість компіляції та запуску тестів у Rust дозволяє отримувати майже
миттєвий зворотний зв’язок, що критично важливо для TDD.

     1.9 Практичні рекомендації
     1.9.1 Робочий процес розробки

     Рекомендований workflow:
     а)    написати код з використанням описових назв;
     б)    запустити “cargo fmt” для автоматичного форматування;
     в)    запустити “cargo clippy” для виявлення проблем;
      г)   написати тести для нового функціоналу;
     д)    запустити “cargo test” для перевірки коректності;
     е)    задокументувати публічний API з прикладами;
     ж)    запустити “cargo doc” для перевірки документації;
     и)    закомітити зміни.

     1.9.2 Налаштування середовища розробки

     Pre-commit хук для автоматизації:
     Створити файл “.git/hooks/pre-commit”:

     #!/bin/sh
     cargo fmt -- --check
     cargo clippy -- -D warnings
     cargo test


     Це забезпечить автоматичну перевірку якості коду перед кожним комітом.

     1.9.3 CI/CD інтеграція

     Приклад GitHub Actions workflow:

     name: Rust Quality

     on: [push, pull_request]
                                                                              16
     jobs:
       check:
         runs-on: ubuntu-latest
         steps:
           - uses: actions/checkout@v2
           - name: Format check
             run: cargo fmt -- --check
           - name: Clippy
             run: cargo clippy -- -D warnings
           - name: Tests
             run: cargo test


     1.10 Висновки

     Правила оформлення програмного коду в екосистемі Rust становлять
комплексну систему стандартів, інструментів та практик, які забезпечують високу
якість програмного забезпечення.
     Ключові висновки роботи:
     а)   Уніфікація стилю через офіційний стандарт та інструмент “rustfmt”
          усуває суперечки та забезпечує консистентність коду в усій екосистемі.
     б)   Автоматизація перевірок за допомогою “clippy” виявляє потенційні
          проблеми на ранніх стадіях розробки та навчає розробників ідіоматичним
          патернам.
     в)   Інтеграція тестування на рівні мови та інструментів робить написання
          тестів природною частиною процесу розробки, а автоматичне тестування
          прикладів у документації гарантує її актуальність.
     г)   Чітка структура проєктів через Cargo забезпечує передбачуваність та
          спрощує навігацію в будь-якому Rust-проєкті.
     д)   Документація як код з підтримкою Markdown та автоматичною
          генерацією HTML перетворює документування на інтегральну частину
          розробки.
     Практичні рекомендації:
      –   завжди використовувати “cargo fmt” перед комітом коду;
      –   регулярно запускати “cargo clippy” для виявлення потенційних проблем;
      –   дотримуватись   конвенцій    іменування,   довіряючи     попередженням
          Компілятора;
      –   документувати весь публічний API з робочими прикладами коду;
                                                                                17
      –   писати тести для критичного функціоналу паралельно з розробкою;
      –   інтегрувати перевірки якості коду в CI/CD pipeline;
      –   використовувати rust-analyzer для підвищення продуктивності розробки.
     Філософія Rust: довіряйте інструментам – екосистема Rust розроблена так,
щоб правильний код був природним, а неправильний – незручним. Компілятор,
лінтер та система типів виступають союзниками розробника в створенні надійного
програмного забезпечення.
     Дотримання правил оформлення коду в Rust не є обтяжливим формальним
процесом, а становить природну частину культури розробки, яка автоматизована та
підтримується потужними інструментами. Це дозволяє розробникам зосередитися
на вирішенні бізнес-задач, довіривши технічні аспекти якості коду перевіреним
інструментам.

     1.11 Список використаних джерел
     1.11.1 Офіційна документація

     1.   The Rust Programming Language (The Rust Book) [Електронний ресурс].
          – Режим доступу: https://doc.rust-lang.org/book/ – Офіційний підручник з
          мови Rust, що покриває всі аспекти від основ до просунутих тем.
     2.   Rust Style Guide [Електронний ресурс]. – Режим доступу: https://doc.rust-
          lang.org/style-guide/ – Офіційний керівництво зі стилю кодування в Rust.
     3.   Rust API Guidelines [Електронний ресурс]. – Режим доступу: https://
          rust-lang.github.io/api-guidelines/ – Набір рекомендацій щодо дизайну
          публічних API в Rust.
     4.   The Cargo Book [Електронний ресурс]. – Режим доступу: https://doc.rust-
          lang.org/cargo/ – Документація по менеджеру пакунків та системі збірки
          Cargo.

     1.11.2 Документація інструментів

     5.   rustfmt Documentation [Електронний ресурс]. – Режим доступу: https://
          rust-lang.github.io/rustfmt/ – Документація інструменту автоматичного
          форматування коду.
                                                                                     18
     6.     Clippy Documentation [Електронний ресурс]. – Режим доступу: https://
            rust-lang.github.io/rust-clippy/ – Документація лінтера Clippy з описом всіх
            перевірок.
     7.     rust-analyzer User Manual [Електронний ресурс]. – Режим доступу: https://
            rust-analyzer.github.io/ – Керівництво користувача для Language Server
            rust-analyzer.

     1.11.3 Додаткові ресурси

       8.    Rust by Example [Електронний ресурс]. – Режим доступу: https://doc.rust-
             lang.org/rust-by-example/ – Колекція прикладів коду для вивчення Rust.
       9.    Fowler, M. Refactoring: Improving the Design of Existing Code / Martin
             Fowler. – 2nd ed. – Addison-Wesley Professional, 2018. – 448 p. – ISBN
             978-0134757599. – Класична праця з рефакторингу програмного коду.
     10.     RustSec Advisory Database [Електронний ресурс]. – Режим доступу:
             https://rustsec.org/ – База даних вразливостей безпеки для Rust-пакунків.

     1.11.4 Примітка

     Вся офіційна документація Rust доступна як онлайн, так і офлайн через
команду “rustup doc”, що забезпечує доступ до документації без підключення до
Інтернету.
                                                                              19
                                  ДОДАТОК А
                                  Відеозапис

Відеозапис презентації практичної роботи: https://youtu.be/bEYcrC3PZBk

Хронологічний опис відеозапису:
00:00 Вступ
00:41 Важливість стандартизації
01:25 Структура проєкту Cargo
02:14 Модулі та організація
02:57 Правила форматування
03:46 Конвенції іменування
04:30 Приклади коду
05:20 Коментарі
06:05 Документація
06:52 rustfmt: автоформатування
07:39 Clippy: розумний лінтер
08:30 Тестування в Rust
09:15 Додаткові інструменти
10:11 Висновки та рекомендації
11:00 Джерела
                                                 20
                  ДОДАТОК Б
                   Презентація




     Правила оформлення програмного коду в
                екосистемі Rust




                                             1




            Чому це важливо?
• Один стиль для всіх: уніфікований досвід
• Читабельність: код легко сканується
• Підтримуваність: простіше рефакторити
• Мінімізація помилок: консистентність
  запобігає багам


                                                 2
                                                                  21




             Структура Проєкту Cargo

  my_project/
  ├── Cargo.toml            # Маніфест проєкту
  ├── Cargo.lock            # Залежності (автогенерований)
  ├── src/
  │   ├── main.rs           # Точка входу для бінарної програми
  │   ├── lib.rs            # Точка входу для бібліотеки
  │   ├── module.rs         # Оголошення модуля
  │   └── module/
  │        ├── mod.rs       # Альтернативне оголошення
  │        └── submodule.rs
  ├── tests/                # Інтеграційні тести
  ├── benches/              # Бенчмарки
  └── examples/             # Приклади використання



                                                                  3



               Модулі та Організація

  // src/lib.rs
  pub mod network {
      pub mod client;
      pub mod server;
  }

  pub mod database {
      pub mod connection;
  }



Принцип: Один модуль = Одна відповідальність

                                                                  4
                                             22




             Форматування: правила

  fn example() {
      if condition {
          // код
      } else {
          // код
      }
  }



   • Відступи: завжди 4 пробіли
   • Довжина рядка: максимум 100 символів
   • Стиль дужок: K&R-подібний
                                             5

               Конвенції іменування


Елемент        Стиль             Приклад
Змінні,
               snake_case        user_name
функції
Типи,
               PascalCase        UserAccount
структури
Константи SCREAMING_SNAKE        MAX_SIZE
Макроси        snake_case!       println!
                                             6
                                                23



          Приклад: добре vs погано

                        Добре:

fn calculate_product(x: i32, y: i32) -> i32 {
    x * y
}



                        Погано:

fn Calculate(X:i32,y:i32) -> i32
{
let z=X*y;
return z;
}
                                                7




    Коментарі: коли використовувати

        Коментуйте "чому", а не "що":

// Погано
let items = Vec::new(); // Створюємо вектор

// Добре
// Використовуємо Vec замість масиву, бо
// розмір не відомий на етапі компіляції
let items = Vec::new();




                                                8
                                               24




         Документація = Частина коду

  /// Обчислює факторіал числа.
  ///
  /// # Examples
  ///
  /// ```
  /// let result = factorial(5);
  /// assert_eq!(result, 120);
  /// ```
  pub fn factorial(n: u32) -> u32 {
      (1..=n).product()
  }




Приклади тестуються автоматично: cargo test
                                               9




                Інструменти: rustfmt

 Автоматичне форматування для всіх проєктів:

  # Форматування проєкту
  cargo fmt

  # Перевірка без змін
  cargo fmt -- --check




                                           10
                                                25



               Інструменти: Clippy

    Розумний лінтер з сотнями перевірок:

# Запуск лінтера
cargo clippy

# Строгий режим (всі попередження = помилки)
cargo clippy -- -D warnings



                     Перевіряє:
              • Неідіоматичний код
              • Потенційні помилки
              • Порушення конвенцій            11


                   Тестування (TDD)

pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}




          Запуск тестів: cargo test
                                               12
                                                    26




           Додаткові інструменти
• cargo-audit: перевірка вразливостей у
  залежностях
• cargo-tarpaulin: аналіз покриття тестами
• cargo-watch: автоматична перекомпіляція
  при змінах
• rust-analyzer: Language Server Protocol для IDE

                                               13




                  Висновки

✓ Використовуйте rustfmt та clippy завжди
    ✓ Дотримуйтесь конвенцій іменування
 ✓ Документуйте публічний API з прикладами
     ✓ Пишіть тести для критичного коду
   ✓ Довіряйте інструментам -- Rust робить
         правильний код природним


                                               14
                                              27


                 Джерела

         Офіційна документація:
     • The Rust Book -- головний підручник
     • Rust Style Guide -- офіційний стиль
     • API Guidelines -- принципи дизайну
               Інструменти:
       • rustfmt -- форматування коду
       • clippy -- лінтер
Вся документація доступна онлайн та офлайн
            через rustup doc              15




      ДЯКУЮ ЗА УВАГУ!



                                             16

